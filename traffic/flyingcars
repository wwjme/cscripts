// === Flying Car Traffic System (tick-based but optimized) ===

// Configuration
var conjunctions = [
    {x: 2000, y: 80, z: 2000},
    {x: 2050, y: 80, z: 2000},
    {x: 2100, y: 80, z: 2050},
    {x: 2000, y: 80, z: 2100}
];

var laneOffset = 4; // distance from the center to each lane
var checkInterval = 40; // every 40 ticks (~2s)
var tolerance = 3; // distance threshold to consider "arrived"

// Local state (non-persistent)
var tickCounter = 0;
var currentTarget = null;

// --- Helper functions ---
function distance(a, b) {
    var dx = a.x - b.x;
    var dy = a.y - b.y;
    var dz = a.z - b.z;
    return Math.sqrt(dx*dx + dy*dy + dz*dz);
}

function nearestConjunction(pos) {
    var nearest = null;
    var bestDist = 999999;
    for (var i in conjunctions) {
        var c = conjunctions[i];
        var d = distance(pos, c);
        if (d < bestDist) {
            bestDist = d;
            nearest = c;
        }
    }
    return nearest;
}

function pickRandomNearbyConjunction(from) {
    var options = [];
    for (var i in conjunctions) {
        var c = conjunctions[i];
        var d = distance(from, c);
        if (d > 10 && d < 120) { // pick relatively close ones
            options.push(c);
        }
    }
    if (options.length == 0) options = conjunctions;
    return options[Math.floor(Math.random() * options.length)];
}

function addLaneOffset(base, direction) {
    // Simple offset for left/right lanes depending on direction
    var dx = 0;
    var dz = 0;

    if (direction == "north" || direction == "south") {
        dx = (Math.random() > 0.5 ? 1 : -1) * laneOffset;
    } else if (direction == "east" || direction == "west") {
        dz = (Math.random() > 0.5 ? 1 : -1) * laneOffset;
    }

    return {x: base.x + dx, y: base.y, z: base.z + dz};
}

// --- Main tick loop ---
function tick(event) {
    tickCounter++;

    // Run heavy logic only every few ticks
    if (tickCounter % checkInterval != 0) return;

    var npc = event.npc;
    var pos = {x: npc.getX(), y: npc.getY(), z: npc.getZ()};

    // If no target, find nearest conjunction
    if (currentTarget == null) {
        currentTarget = nearestConjunction(pos);
        npc.navigateTo(currentTarget.x, currentTarget.y, currentTarget.z, 1.2);
        return;
    }

    // Check if near target
    var dist = distance(pos, currentTarget);
    if (dist <= tolerance) {
        // Reached target â€” pick new one
        var next = pickRandomNearbyConjunction(currentTarget);
        currentTarget = next;
        npc.navigateTo(next.x, next.y, next.z, 1.2);
    }
}
