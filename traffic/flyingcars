
// -------- CONFIG -------- //
var laneOffset = 10;     // Distance from junction center to lane
var flyHeight = 2;      // Lift target Y for better flying nav
var speed = 1.3;        // Flying car navigation speed
var checkInterval = 1; // How often to update logic (ticks)
var arriveRange = 4;    // Distance threshold for "arrival"

// List of junction centers (x, y, z)
var junctions = [
    {x: 59, y: -54, z: 2},
    {x: 59, y: -54, z: -76},
    {x: 59, y: -54, z: -76},
    {x: -5, y: -54, z: 3}
];

// -------- INTERNAL STATE -------- //
var currentTarget = null;
var currentDir = null;
var tickCounter = 0;

// =============================== //
//             INIT                //
// =============================== //
function init(event) {
    var npc = event.npc;
    npc.ai.stopOnInteract = false;
    npc.ai.returnsHome = false;
    npc.getAi().setNavigationType(1);

    var dirs = ["north", "south", "east", "west"];
    currentDir = dirs[Math.floor(Math.random() * dirs.length)];

    npc.say("Init dir: " + currentDir);
}

// =============================== //
//             TICK                //
// =============================== //
function tick(event) {
    tickCounter++;
    if (tickCounter % checkInterval != 0) return;

    var npc = event.npc;
    var pos = npc.getPos();

    // 1️⃣ If no target yet — find nearest junction and move toward it
    if (!currentTarget) {
        currentTarget = findNearestJunction(pos);
        if (!currentTarget) {
            npc.say("No junction found.");
            return;
        }

        var lane = getLanePosition(currentTarget, currentDir);
        npc.navigateTo(lane.x, currentTarget.y + flyHeight, lane.z, speed);
        npc.say("Navigating to first target at " + lane.x + ", " + lane.z);
        return;
    }

    // 2️⃣ Check if near current target
    if (isNear(pos, currentTarget, arriveRange)) {
        var nextDir = chooseNextDirection(currentDir);
        currentDir = nextDir;

        var nextJunction = findNearbyJunction(currentTarget, 200);
        if (!nextJunction) nextJunction = findNearestJunction(pos);

        currentTarget = nextJunction;
        var lane = getLanePosition(nextJunction, nextDir);
        npc.navigateTo(lane.x, nextJunction.y + flyHeight, lane.z, speed);
        npc.say("Next target: " + lane.x + ", " + lane.z + " dir=" + nextDir);
    } else {
        // If navigation canceled or NPC stopped midair, reissue move
        if (!npc.isNavigating()) {
            var lane = getLanePosition(currentTarget, currentDir);
            npc.navigateTo(lane.x, currentTarget.y + flyHeight, lane.z, speed);
            npc.say("Reissuing navigateTo.");
        }
    }
}

// =============================== //
//        HELPER FUNCTIONS         //
// =============================== //

function findNearestJunction(pos) {
    var nearest = null;
    var bestDist = 999999;
    for each (var j in junctions) {
        var dx = pos.getX() - j.x;
        var dz = pos.getZ() - j.z;
        var dist = Math.sqrt(dx*dx + dz*dz);
        if (dist < bestDist) {
            bestDist = dist;
            nearest = j;
        }
    }
    return nearest;
}

function findNearbyJunction(current, maxDist) {
    var candidates = [];
    for each (var j in junctions) {
        var dx = j.x - current.x;
        var dz = j.z - current.z;
        var dist = Math.sqrt(dx*dx + dz*dz);
        if (dist > 1 && dist < maxDist) candidates.push(j);
    }
    if (candidates.length == 0) return null;
    return candidates[Math.floor(Math.random() * candidates.length)];
}

function getLanePosition(junction, direction) {
    var x = junction.x;
    var z = junction.z;
    switch (direction) {
        case "north": return {x: x, z: z - laneOffset};
        case "south": return {x: x, z: z + laneOffset};
        case "east":  return {x: x + laneOffset, z: z};
        case "west":  return {x: x - laneOffset, z: z};
        default:      return {x: x, z: z};
    }
}

function chooseNextDirection(fromDir) {
    var choices = {
        north: ["north", "west", "east"],
        south: ["south", "west", "east"],
        east:  ["east", "north", "south"],
        west:  ["west", "north", "south"]
    };
    var options = choices[fromDir];
    return options[Math.floor(Math.random() * options.length)];
}

function isNear(pos, target, dist) {
    var dx = pos.getX() - target.x;
    var dz = pos.getZ() - target.z;
    return Math.sqrt(dx*dx + dz*dz) <= dist;
}
