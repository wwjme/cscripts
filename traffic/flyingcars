// -------- CONFIG -------- //
var laneOffset = 10;    // Distance from junction center to lane
var flyHeight = 2;      // Lift target Y relative to NPC pos
var speed = 1.3;        // Flying car navigation speed
var checkInterval = 1;  // How often to update logic (ticks)
var arriveRange = 10;   // Distance threshold for "arrival"

// List of junction centers (x, y, z)
var junctions = [
    {x: 59, y: -54, z: 2},
    {x: 59, y: -54, z: -76},
    {x: -5, y: -54, z: 3}
];

// -------- INTERNAL STATE -------- //
var currentTarget = null;
var currentDir = null;
var tickCounter = 0;

// =============================== //
//             INIT                //
// =============================== //
function init(event) {
    var npc = event.npc;
    npc.ai.stopOnInteract = false;
    npc.ai.returnsHome = false;
    npc.getAi().setNavigationType(1); // Flying
    npc.getAi().setMovingType(1);     // Moving type: wandering allowed

    var dirs = ["north", "south", "east", "west"];
    currentDir = dirs[Math.floor(Math.random() * dirs.length)];

    npc.say("Init dir: " + currentDir);
}

// =============================== //
//             TICK                //
// =============================== //
function tick(event) {
    tickCounter++;
    if (tickCounter % checkInterval != 0) return;

    var npc = event.npc;
    var pos = npc.getPos();

    // If no target yet, set initial
    if (!currentTarget) {
        currentTarget = findNearestJunction(pos);
        if (!currentTarget) return;

        goToTarget(npc, currentTarget, currentDir);
        return;
    }

    // If close to target, pick next
    if (isNear(pos, currentTarget, arriveRange)) {
        var nextDir = chooseNextDirection(currentDir);
        currentDir = nextDir;

        // ðŸ”¹ Only pick junctions that align (no diagonals)
        var nextJunction = findNearbyAlignedJunction(currentTarget, 200, nextDir);
        if (!nextJunction) nextJunction = findNearestJunction(pos);

        currentTarget = nextJunction;
        goToTarget(npc, currentTarget, currentDir);
        npc.say("Next: " + nextDir + " -> (" + currentTarget.x + "," + currentTarget.z + ")");
    } else {
        // Navigation may randomly stop â€” reissue only if far enough
        if (!npc.isNavigating()) {
            var dist = getDist2D(pos, currentTarget);
            if (dist > arriveRange + 1) {
                goToTarget(npc, currentTarget, currentDir);
                npc.say("Reissuing navigateTo (" + dist.toFixed(1) + ")");
            }
        }
    }
}

// =============================== //
//         MOVE FUNCTION           //
// =============================== //
function goToTarget(npc, target, dir) {
    var lane = getLanePosition(target, dir);
    var pos = npc.getPos();

    // Add small randomization to avoid pathfinder deadlocks
    var rx = lane.x + (Math.random() - 0.5);
    var rz = lane.z + (Math.random() - 0.5);
    var ry = pos.getY() + flyHeight;

    // Prevent reissue if target too close
    var dx = pos.getX() - rx;
    var dz = pos.getZ() - rz;
    if (Math.sqrt(dx * dx + dz * dz) < 1.5) return;

    npc.navigateTo(rx, ry, rz, speed);
}

// =============================== //
//        HELPER FUNCTIONS         //
// =============================== //

function findNearestJunction(pos) {
    var nearest = null;
    var bestDist = 999999;
    for each (var j in junctions) {
        var dx = pos.getX() - j.x;
        var dz = pos.getZ() - j.z;
        var dist = Math.sqrt(dx*dx + dz*dz);
        if (dist < bestDist) {
            bestDist = dist;
            nearest = j;
        }
    }
    return nearest;
}

// ðŸ”¹ NEW: Find only junctions that align straight with current direction
function findNearbyAlignedJunction(current, maxDist, dir) {
    var candidates = [];
    for each (var j in junctions) {
        var dx = j.x - current.x;
        var dz = j.z - current.z;
        var dist = Math.sqrt(dx*dx + dz*dz);
        if (dist < 1 || dist > maxDist) continue;

        // Only allow junctions directly in line â€” not diagonal
        if ((dir === "north" || dir === "south") && Math.abs(dx) < 2) candidates.push(j);
        else if ((dir === "east" || dir === "west") && Math.abs(dz) < 2) candidates.push(j);
    }
    if (candidates.length == 0) return null;
    return candidates[Math.floor(Math.random() * candidates.length)];
}

function getLanePosition(junction, direction) {
    var x = junction.x;
    var z = junction.z;
    switch (direction) {
        case "north": return {x: x, z: z - laneOffset};
        case "south": return {x: x, z: z + laneOffset};
        case "east":  return {x: x + laneOffset, z: z};
        case "west":  return {x: x - laneOffset, z: z};
        default:      return {x: x, z: z};
    }
}

function chooseNextDirection(fromDir) {
    var choices = {
        north: ["north", "west", "east"],
        south: ["south", "west", "east"],
        east:  ["east", "north", "south"],
        west:  ["west", "north", "south"]
    };
    var options = choices[fromDir];
    return options[Math.floor(Math.random() * options.length)];
}

function isNear(pos, target, dist) {
    return getDist2D(pos, target) <= dist;
}

function getDist2D(pos, target) {
    var dx = pos.getX() - target.x;
    var dz = pos.getZ() - target.z;
    return Math.sqrt(dx * dx + dz * dz);
}
